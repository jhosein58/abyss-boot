use crate::target::Target;
use abyss_analyzer::lir::LirType;

pub struct CTarget {
    output: String,
    indent_level: usize,
}

impl CTarget {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }

    fn push_indent(&mut self) {
        self.indent_level += 1;
    }

    fn pop_indent(&mut self) {
        self.indent_level -= 1;
    }

    fn emit(&mut self, text: &str) {
        let indent = "    ".repeat(self.indent_level);
        self.output.push_str(&format!("\n{}{}", indent, text));
    }

    fn type_to_c(&self, ty: &LirType) -> String {
        match ty {
            LirType::I64 => "long long".to_string(),
            LirType::U8 => "unsigned char".to_string(),
            LirType::F64 => "double".to_string(),
            LirType::Bool => "int".to_string(),
            LirType::Void => "void".to_string(),
            LirType::Pointer(inner) => format!("{}*", self.type_to_c(inner)),
            _ => "".to_string(),
        }
    }

    pub fn get_code(&self) -> &str {
        &self.output
    }

    fn params_to_func_args(&self, params: &[(String, LirType)]) -> String {
        params
            .iter()
            .map(|(name, ty)| format!("{} {}", self.type_to_c(ty), name))
            .collect::<Vec<String>>()
            .join(", ")
    }

    fn func_signature(
        &self,
        name: &str,
        params: &[(String, LirType)],
        return_type: &LirType,
    ) -> String {
        format!("{} {}(", self.type_to_c(return_type), name)
            + &self.params_to_func_args(params)
            + ")"
    }
}

impl Target for CTarget {
    fn start_program(&mut self) {
        self.output.clear();

        self.emit("");
        self.emit("// --- Generated by Abyss CTarget ---");
        self.emit("");
    }

    fn end_program(&mut self) {
        self.indent_level = 0;

        self.emit("");
        self.emit("// --- End of generated code ---");
        self.emit("");
        self.emit("int main(void) {");
        self.emit("    entry();");
        self.emit("    return 0;");
        self.emit("}");
    }

    fn declare_extern_function(
        &mut self,
        name: &str,
        params: &[(String, LirType)],
        return_type: &LirType,
    ) {
        self.emit(&("extern".to_owned() + &self.func_signature(name, params, return_type) + ";"));
    }

    fn declare_function_proto(
        &mut self,
        name: &str,
        params: &[(String, LirType)],
        return_type: &LirType,
    ) {
        self.emit(&(self.func_signature(name, params, return_type) + ";"));
    }

    fn begin_function(&mut self, name: &str, params: &[(String, LirType)], return_type: &LirType) {
        self.emit(&(self.func_signature(name, params, return_type) + " {"));
        self.push_indent();
    }

    fn end_function(&mut self) {
        self.pop_indent();
        self.emit("}");
    }
}
